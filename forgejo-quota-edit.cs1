#!/usr/bin/env -S dotnet run --file
#:package ForgejoApiClient@13.0.0-rev.2
#:package Kokuban@0.2.0
#:package Lestaly.General@0.114.0
#:package RefFile@0.2.0
#:property PublishAot=false
using System.Buffers;
using ForgejoApiClient;
using ForgejoApiClient.Api;
using Kokuban;
using Lestaly;
[assembly: RefFile(".env-helper.cs1")]

// 設定
var settings = new
{
    // Forgejo 関連の情報
    Forgejo = new
    {
        // サービスURL
        ServiceURL = new Uri("http://localhost:9950/"),

        // APIキー保存ファイル
        ApiTokenFile = ThisSource.RelativeFile(".auth-forgejo-api"),
    },
};

// コマンド定義
CommandDefine makeCommandDefines() => new CommandDefine("root", "", Subs:
[
    new("subjects", "制限対象一覧", Aliases: ["s", "subject"], Handler: cmdSubjectsAsync),
    new("rule", "クォータルール関連", Aliases: ["r", "rules"], Subs:
    [
        new("list",   "  ルールリスト取得", Handler: cmdRuleListAsync, Aliases: ["l"]),
        new("info",   "  ルール情報表示", Handler: cmdRuleInfoAsync, Aliases: ["i"]),
        new("create", "  ルール作成", Handler: cmdRuleCreateAsync),
        new("delete", "  ルール削除", Handler: cmdRuleDeleteAsync),
    ]),
    new("group", "クォータグループ関連", Aliases: ["g", "groups"], Subs:
    [
        new("list",   "  グループリスト取得", Handler: cmdGroupListAsync, Aliases: ["l"]),
        new("info",   "  グループ情報表示", Handler: cmdGroupInfoAsync, Aliases: ["i"]),
        new("create", "  グループ作成", Handler: cmdGroupCreateAsync),
        new("delete", "  グループ削除", Handler: cmdGroupDeleteAsync),
        new("rule",   "  グループのルール関連", Aliases: ["r", "rules"], Subs:
        [
            new("add",    "    ルール追加", Handler: cmdGroupRuleAddAsync),
            new("remove", "    ルール除去", Handler: cmdGroupRuleRemoveAsync)
        ]),
        new("user", "  グループのユーザ関連", Aliases: ["u", "users"], Subs:
        [
            new("list",   "    ユーザリスト取得", Handler: cmdGroupUserListAsync, Aliases: ["l"]),
            new("add",    "    ユーザ追加", Handler: cmdGroupUserAddAsync),
            new("remove", "    ユーザ除去", Handler: cmdGroupUserRemoveAsync)
        ]),
    ]),
    new("user", "ユーザのクォータ情報関連", Aliases: ["u", "users"], Subs:
    [
        new("info",        "  クォータ情報取得", Handler: cmdUserInfoAsync, Aliases: ["i"]),
        new("check",       "  クォータ超過チェック", Handler: cmdUserCheckAsync, Aliases: ["c"]),
        new("packages",    "  パッケージのクォータ使用量", Handler: cmdUserPackagesAsync),
        new("attachments", "  添付データのクォータ使用量", Handler: cmdUserAttachmentsAsync),
        new("artifacts",   "  関連データのクォータ使用量", Handler: cmdUserArtifactsAsync),
    ]),
    new("org", "組織のクォータ情報関連", Aliases: ["o"], Subs:
    [
        new("info",        "  クォータ情報取得", Handler: cmdOrgInfoAsync, Aliases: ["i"]),
        new("check",       "  クォータ超過チェック", Handler: cmdOrgCheckAsync, Aliases: ["c"]),
        new("packages",    "  パッケージのクォータ使用量", Handler: cmdOrgPackagesAsync),
        new("attachments", "  添付データのクォータ使用量", Handler: cmdOrgAttachmentsAsync),
        new("artifacts",   "  関連データのクォータ使用量", Handler: cmdOrgArtifactsAsync),
    ]),
    new("help", "コマンド一覧", Handler: cmdHelpAsync, Aliases: ["h", "?"]),
]);

// メイン処理
return await Paved.ProceedAsync(async () =>
{
    // コンソール準備
    using var signal = new SignalCancellationPeriod();

    // タイトル出力
    void WriteScriptTitle()
    {
        const string ScriptTitle = "ForgejoのQuota管理ヘルパ";
        Console.WriteLine(ScriptTitle);
        Console.WriteLine($"  Forgejo   : {settings.Forgejo.ServiceURL}");
        Console.WriteLine();
    }

    // 認証情報を準備
    WriteScriptTitle();
    Console.WriteLine("サービス認証情報の準備");
    var forgejoToken = await settings.Forgejo.ApiTokenFile.BindTokenAsync("Forgejo APIトークン", settings.Forgejo.ServiceURL, signal.Token);
    Console.Clear();
    WriteScriptTitle();

    // APIクライアントを準備
    Console.WriteLine("Forgejo クライアントの生成 ...");
    using var forgejo = new ForgejoClient(forgejoToken.Service, forgejoToken.Token);
    var apiUser = await forgejo.User.GetMeAsync(cancelToken: signal.Token);
    Console.WriteLine(Chalk.Gray[$"  .. User: {apiUser.login}"]);
    Console.WriteLine();
    if (apiUser.is_admin != true) throw new PavedMessageException("APIトークンのユーザが管理者ではない。", PavedMessageKind.Warning);

    // 情報をまとめた実行コンテキスト情報を生成
    var commands = makeCommandDefines();
    var context = new ManageContext(forgejo, commands, signal.Token);

    // コマンド処理
    Console.WriteLine("コマンド入力 ('help' でコマンドリスト表示)");
    while (true)
    {
        // コマンド入力
        Console.Write(">");
        var input = Console.ReadLine();
        if (input == null) break;
        if (input.IsWhite()) continue;

        try
        {
            // コマンド定義取得
            var define = commands.SelectCommand(input.AsMemory(), out var args);
            if (define == null) throw new PavedMessageException("コマンドが正しくない", PavedMessageKind.Warning);
            if (define.Handler == null)
            {
                if (define.Subs == null || define.Subs.Length <= 0) throw new PavedMessageException("コマンドが正しくない", PavedMessageKind.Warning);
                Console.WriteLine("サブコマンド一覧：");
                var subList = define.Subs.Select(s => (path: s.MekeCommandPath(), desc: s.Description));
                var pathWidth = subList.Max(c => c.path.Length);
                foreach (var subCmd in subList)
                {
                    Console.WriteLine($"{subCmd.path.PadRight(pathWidth)} : {subCmd.desc}");
                }
            }
            else
            {
                // コマンドハンドラを実行
                await define.Handler.Invoke(context, args);
            }
        }
        catch (Exception ex)
        {
            var color = (ex as PavedMessageException)?.Kind switch
            {
                PavedMessageKind.Information => Chalk.Gray,
                PavedMessageKind.Warning or PavedMessageKind.Cancelled => Chalk.Yellow,
                _ => Chalk.Red,
            };
            Console.WriteLine(color[ex.Message]);
        }
        Console.WriteLine();
    }
});

/// <summary>未実装コマンド</summary>
#pragma warning disable CS8321 // ローカル関数は宣言されていますが、一度も使用されていません
async ValueTask cmdNotImplementedAsync(ManageContext context, ReadOnlyMemory<char> arguments)
{
    await Task.CompletedTask;
    Console.WriteLine(Chalk.Yellow["コマンド未実装"]);
}
#pragma warning restore CS8321 // ローカル関数は宣言されていますが、一度も使用されていません

/// <summary>help コマンド</summary>
async ValueTask cmdHelpAsync(ManageContext context, ReadOnlyMemory<char> arguments)
{
    await Task.CompletedTask;

    // コマンド一覧を列挙
    static IEnumerable<(string token, string desc)> enumCommands(int level, CommandDefine[] commands)
    {
        var indent = string.Create(level * 2, ' ', (span, state) => span.Fill(state));
        foreach (var cmd in commands)
        {
            yield return ($"{indent}{cmd.Token}", cmd.Description);
            if (cmd.Subs == null) continue;
            foreach (var subCmd in enumCommands(level + 1, cmd.Subs))
            {
                yield return subCmd;
            }
        }
    }

    // コマンド一覧を出力
    Console.WriteLine("コマンド一覧：");
    var cmdList = enumCommands(level: 0, context.Commands.Subs!).ToArray();
    var tokenWidth = cmdList.Max(c => c.token.Length);
    foreach (var cmd in cmdList)
    {
        Console.WriteLine($"{cmd.token.PadRight(tokenWidth)} : {cmd.desc}");
    }

    Console.WriteLine();
    Console.WriteLine("各コマンドのパラメータに --help を含めるとコマンドのヘルプを表示する。");
}

/// <summary>subjects コマンド</summary>
async ValueTask cmdSubjectsAsync(ManageContext context, ReadOnlyMemory<char> arguments)
{
    // ヘルプ表示
    if (arguments.Span.IncludeToken("--help"))
    {
        Console.WriteLine("subjects");
        Console.WriteLine("    パラメータなし");
        return;
    }

    // 表示
    Console.WriteLine("""
    size:all                             : すべてのデータサイズ
    size:git:all                         : Gitデータサイズ (LFSを含む)
      size:git:lfs                       : Git LFS データサイズ
    size:repos:all                       : リポジトリデータサイズ (LDSを含まない)
        size:repos:public                : [NOT YET AVAILABLE] 公開リポジトリデータサイズ (LDSを含まない)
        size:repos:private               : [NOT YET AVAILABLE] 非公開リポジトリデータサイズ (LDSを含まない)
    size:assets:all                      : すべての追跡データサイズ
      size:assets:attachments:all        : 添付データサイズ
        size:assets:attachments:issues   : イシューへの添付データサイス
        size:assets:attachments:releases : リリースへの添付データサイス(自動アーカイブを除く)
      size:assets:artifacts              : アーティファクト(どれ？)のサイズ
      size:assets:packages:all           : パッケージのサイズ
      size:assets:wiki                   : Wiki サイズ.
    """);

    await Task.CompletedTask;
}

/// <summary>rule list コマンド</summary>
async ValueTask cmdRuleListAsync(ManageContext context, ReadOnlyMemory<char> arguments)
{
    // ヘルプ表示
    if (arguments.Span.IncludeToken("--help"))
    {
        Console.WriteLine("rule list [--detail]");
        Console.WriteLine("    --detail : 含まれる制限対象を表示する");
        return;
    }

    // パラメータ取得
    var detail = arguments.Span.IncludeToken("--detail");

    // 情報取得・表示
    var rules = await context.Client.Admin.ListQuotaRulesAsync(context.Breaker);
    foreach (var rule in rules)
    {
        Console.WriteLine($"Name={rule.name}, Limit={(rule.limit ?? 0).ToHumanize()}, {rule.subjects?.Count ?? 0} subjects");
        if (detail && rule.subjects != null)
        {
            foreach (var subject in rule.subjects)
            {
                Console.WriteLine($"  {subject}");
            }
        }
    }
}

/// <summary>rule info コマンド</summary>
async ValueTask cmdRuleInfoAsync(ManageContext context, ReadOnlyMemory<char> arguments)
{
    // ヘルプ表示
    if (arguments.Span.IncludeToken("--help"))
    {
        Console.WriteLine("rule info <name>");
        Console.WriteLine("    name : 対象ルール名称");
        return;
    }

    // パラメータ取得
    var name = arguments.TakeArgument(out arguments).ToString().ThrowIfWhite(() => new Exception($"name は必須です。"));

    // 情報取得・表示
    var rule = await context.Client.Admin.GetQuotaRuleAsync(name, context.Breaker);
    Console.WriteLine($"Name: {rule.name}");
    Console.WriteLine($"Limit: {(rule.limit ?? 0).ToHumanize()}");
    if (0 < rule.subjects?.Count)
    {
        Console.WriteLine($"Subjects:");
        foreach (var subject in rule.subjects)
        {
            Console.WriteLine($" - {subject}");
        }
    }
}

/// <summary>rule create コマンド</summary>
async ValueTask cmdRuleCreateAsync(ManageContext context, ReadOnlyMemory<char> arguments)
{
    // ヘルプ表示
    if (arguments.Span.IncludeToken("--help"))
    {
        Console.WriteLine("rule create <name> <limit> <subject> [<subject>..]");
        Console.WriteLine("    name    : 対象ルール名称");
        Console.WriteLine("    limit   : 制限サイズ");
        Console.WriteLine("    subject : 制限対象");
        return;
    }

    // パラメータ取得
    var name = arguments.TakeArgument(out arguments).ToString().ThrowIfWhite(() => new Exception($"name は必須です。"));
    var limit = arguments.TakeArgument(out arguments).TryParseHumanized() ?? throw new PavedMessageException($"limit を解釈できません。");
    var subjects = arguments.TakeArgList();

    // 検証
    if (subjects.Count <= 0) throw new PavedMessageException($"1つ以上の subject を指定する必要があります。");

    // 実行・結果表示
    var options = new CreateQuotaRuleOptions(name: name, limit: limit, subjects: subjects);
    var rule = await context.Client.Admin.CreateQuotaRuleAsync(options, context.Breaker);
    Console.WriteLine($"Name: {rule.name}");
    Console.WriteLine($"Limit: {(rule.limit ?? 0).ToHumanize()}");
    if (0 < rule.subjects?.Count)
    {
        Console.WriteLine($"Subjects:");
        foreach (var subject in rule.subjects)
        {
            Console.WriteLine($" - {subject}");
        }
    }
}

/// <summary>rule delete コマンド</summary>
async ValueTask cmdRuleDeleteAsync(ManageContext context, ReadOnlyMemory<char> arguments)
{
    // ヘルプ表示
    if (arguments.Span.IncludeToken("--help"))
    {
        Console.WriteLine("rule delete <name>");
        Console.WriteLine("    name    : 対象ルール名称");
        return;
    }

    // パラメータ取得
    var name = arguments.TakeArgument(out arguments).ToString().ThrowIfWhite(() => new Exception($"name は必須です。"));

    // 実行・結果表示
    await context.Client.Admin.DeleteQuotaRuleAsync(name, context.Breaker);
    Console.WriteLine($"ルール '{name}' を削除しました。");
}

/// <summary>group list コマンド</summary>
async ValueTask cmdGroupListAsync(ManageContext context, ReadOnlyMemory<char> arguments)
{
    // ヘルプ表示
    if (arguments.Span.IncludeToken("--help"))
    {
        Console.WriteLine("group list [--detail]");
        Console.WriteLine("    --detail : 含まれるルールを表示する");
        return;
    }

    // パラメータ取得
    var detail = arguments.Span.IncludeToken("--detail");

    // 情報取得・表示
    var groups = await context.Client.Admin.ListQuotaGroupsAsync(context.Breaker);
    foreach (var group in groups)
    {
        Console.WriteLine($"Name={group.name}, {group.rules?.Count ?? 0} rules");
        if (detail && group.rules != null)
        {
            foreach (var rule in group.rules)
            {
                Console.WriteLine($"  Name={rule.name}, Limit={(rule.limit ?? 0).ToHumanize()}, {rule.subjects?.Count ?? 0} subjects");
            }
        }
    }
}

/// <summary>group list コマンド</summary>
async ValueTask cmdGroupInfoAsync(ManageContext context, ReadOnlyMemory<char> arguments)
{
    // ヘルプ表示
    if (arguments.Span.IncludeToken("--help"))
    {
        Console.WriteLine("group info <name>");
        Console.WriteLine("    name : 対象グループ名称");
        return;
    }

    // パラメータ取得
    var name = arguments.TakeArgument(out arguments).ToString().ThrowIfWhite(() => new Exception($"name は必須です。"));

    // 情報取得・表示
    var group = await context.Client.Admin.GetQuotaGroupAsync(name, context.Breaker);
    Console.WriteLine($"Name={group.name}");
    if (0 < group.rules?.Count)
    {
        Console.WriteLine($"Rules:");
        foreach (var rule in group.rules)
        {
            Console.WriteLine($" - Name={rule.name}, Limit={(rule.limit ?? 0).ToHumanize()}, {rule.subjects?.Count ?? 0} subjects");
        }
    }
}

/// <summary>group create コマンド</summary>
async ValueTask cmdGroupCreateAsync(ManageContext context, ReadOnlyMemory<char> arguments)
{
    // ヘルプ表示
    if (arguments.Span.IncludeToken("--help"))
    {
        Console.WriteLine("group create <name>");
        Console.WriteLine("    name    : 対象グループ名称");
        return;
    }

    // パラメータ取得
    var name = arguments.TakeArgument(out arguments).ToString().ThrowIfWhite(() => new Exception($"name は必須です。"));

    // 実行・結果表示
    var options = new CreateQuotaGroupOptions(name: name);
    var group = await context.Client.Admin.CreateQuotaGroupAsync(options, context.Breaker);
    Console.WriteLine($"Name={group.name}");
    if (0 < group.rules?.Count)
    {
        Console.WriteLine($"Rules:");
        foreach (var rule in group.rules)
        {
            Console.WriteLine($" - Name={rule.name}, Limit={(rule.limit ?? 0).ToHumanize()}, {rule.subjects?.Count ?? 0} subjects");
        }
    }
}

/// <summary>group delete コマンド</summary>
async ValueTask cmdGroupDeleteAsync(ManageContext context, ReadOnlyMemory<char> arguments)
{
    // ヘルプ表示
    if (arguments.Span.IncludeToken("--help"))
    {
        Console.WriteLine("group delete <name>");
        Console.WriteLine("    name    : 対象グループ名称");
        return;
    }

    // パラメータ取得
    var name = arguments.TakeArgument(out arguments).ToString().ThrowIfWhite(() => new Exception($"name は必須です。"));

    // 実行・結果表示
    await context.Client.Admin.DeleteQuotaGroupAsync(name, context.Breaker);
    Console.WriteLine($"グループ '{name}' を削除しました。");
}

/// <summary>group rule add コマンド</summary>
async ValueTask cmdGroupRuleAddAsync(ManageContext context, ReadOnlyMemory<char> arguments)
{
    // ヘルプ表示
    if (arguments.Span.IncludeToken("--help"))
    {
        Console.WriteLine("group rule add <group> <rule>");
        Console.WriteLine("    group : 追加先グループ名");
        Console.WriteLine("    rule  : 追加するルール名");
        return;
    }

    // パラメータ取得
    var group = arguments.TakeArgument(out arguments).ToString().ThrowIfWhite(() => new Exception($"group は必須です。"));
    var rule = arguments.TakeArgument(out arguments).ToString().ThrowIfWhite(() => new Exception($"rule は必須です。"));

    // 情報取得・表示
    await context.Client.Admin.AddQuotaGroupRuleAsync(group, rule, context.Breaker);
    Console.WriteLine($"グループ '{group}' にルール '{rule}' を追加しました。");
}

/// <summary>group rule remove コマンド</summary>
async ValueTask cmdGroupRuleRemoveAsync(ManageContext context, ReadOnlyMemory<char> arguments)
{
    // ヘルプ表示
    if (arguments.Span.IncludeToken("--help"))
    {
        Console.WriteLine("group rule remove <group> <rule>");
        Console.WriteLine("    group : 削除対象グループ名");
        Console.WriteLine("    rule  : 削除するルール名");
        return;
    }

    // パラメータ取得
    var group = arguments.TakeArgument(out arguments).ToString().ThrowIfWhite(() => new Exception($"group は必須です。"));
    var rule = arguments.TakeArgument(out arguments).ToString().ThrowIfWhite(() => new Exception($"rule は必須です。"));

    // 情報取得・表示
    await context.Client.Admin.RemoveQuotaGroupRuleAsync(group, rule, context.Breaker);
    Console.WriteLine($"グループ '{group}' からルール '{rule}' を除去しました。");
}

/// <summary>group user list コマンド</summary>
async ValueTask cmdGroupUserListAsync(ManageContext context, ReadOnlyMemory<char> arguments)
{
    // ヘルプ表示
    if (arguments.Span.IncludeToken("--help"))
    {
        Console.WriteLine("group user list <group>");
        Console.WriteLine("    group : 対象グループ名");
        return;
    }

    // パラメータ取得
    var group = arguments.TakeArgument(out arguments).ToString().ThrowIfWhite(() => new Exception($"group は必須です。"));

    // 情報取得・表示
    var users = await context.Client.Admin.ListQuotaGroupUsersAsync(group, context.Breaker);
    if (0 < users?.Length)
    {
        Console.WriteLine($"Users:");
        foreach (var user in users ?? [])
        {
            Console.WriteLine($" - Name={user.login}");
        }
    }
    else
    {
        Console.WriteLine($"ユーザが割り当てられていません");
    }
}

/// <summary>group user add コマンド</summary>
async ValueTask cmdGroupUserAddAsync(ManageContext context, ReadOnlyMemory<char> arguments)
{
    // ヘルプ表示
    if (arguments.Span.IncludeToken("--help"))
    {
        Console.WriteLine("group user add <group> <user>");
        Console.WriteLine("    group : 追加先グループ名");
        Console.WriteLine("    user  : 追加するユーザ名");
        return;
    }

    // パラメータ取得
    var group = arguments.TakeArgument(out arguments).ToString().ThrowIfWhite(() => new Exception($"group は必須です。"));
    var user = arguments.TakeArgument(out arguments).ToString().ThrowIfWhite(() => new Exception($"user は必須です。"));

    // 情報取得・表示
    await context.Client.Admin.AddQuotaGroupUserAsync(group, user, context.Breaker);
    Console.WriteLine($"グループ '{group}' にユーザ '{user}' を追加しました。");
}

/// <summary>group user remove コマンド</summary>
async ValueTask cmdGroupUserRemoveAsync(ManageContext context, ReadOnlyMemory<char> arguments)
{
    // ヘルプ表示
    if (arguments.Span.IncludeToken("--help"))
    {
        Console.WriteLine("group user remove <group> <user>");
        Console.WriteLine("    group : 削除対象グループ名");
        Console.WriteLine("    user  : 削除するユーザ名");
        return;
    }

    // パラメータ取得
    var group = arguments.TakeArgument(out arguments).ToString().ThrowIfWhite(() => new Exception($"group は必須です。"));
    var user = arguments.TakeArgument(out arguments).ToString().ThrowIfWhite(() => new Exception($"user は必須です。"));

    // 情報取得・表示
    await context.Client.Admin.RemoveQuotaGroupUserAsync(group, user, context.Breaker);
    Console.WriteLine($"グループ '{group}' からユーザ '{user}' を除去しました。");
}

/// <summary>user info コマンド</summary>
async ValueTask cmdUserInfoAsync(ManageContext context, ReadOnlyMemory<char> arguments)
{
    // ヘルプ表示
    if (arguments.Span.IncludeToken("--help"))
    {
        Console.WriteLine("user info <user>");
        Console.WriteLine("    user : 対象ユーザ名");
        return;
    }

    // パラメータ取得
    var user = arguments.TakeArgument(out arguments).ToString().ThrowIfWhite(() => new Exception($"user は必須です。"));

    // 情報取得・表示
    var info = await context.Client.Admin.GetUserQuotaRuleAsync(user, context.Breaker);
    Console.WriteLine($"Used:");
    if (info.used?.size is var used && used != null)
    {
        if (used.assets != null)
        {
            Console.WriteLine($"  Assets:");
            Console.WriteLine($"    Artifacts = {used.assets.artifacts?.ToHumanize()}");
            Console.WriteLine($"    Attachments:");
            if (used.assets.attachments != null)
            {
                Console.WriteLine($"      Issues   = {used.assets.attachments.issues?.ToHumanize()}");
                Console.WriteLine($"      Releases = {used.assets.attachments.releases?.ToHumanize()}");
            }
            Console.WriteLine($"    Packages:");
            if (used.assets.packages != null)
            {
                Console.WriteLine($"      All = {used.assets.packages.all?.ToHumanize()}");
            }
        }
        if (used.git != null)
        {
            Console.WriteLine($"  Git:");
            Console.WriteLine($"    LFS = {used.git.LFS?.ToHumanize()}");
        }
        if (used.repos != null)
        {
            Console.WriteLine($"  Repos:");
            Console.WriteLine($"    Public  = {used.repos.@public?.ToHumanize()}");
            Console.WriteLine($"    Private = {used.repos.@private?.ToHumanize()}");
        }
    }
    if (0 < info.groups?.Count)
    {
        foreach (var group in info.groups)
        {
            Console.WriteLine($"Group: Name={group.name}");
            foreach (var rule in group.rules ?? [])
            {
                Console.WriteLine($" - Rule: Name={rule.name}, Limit={rule.limit?.ToHumanize()}");
            }
        }
    }
}

/// <summary>user check コマンド</summary>
async ValueTask cmdUserCheckAsync(ManageContext context, ReadOnlyMemory<char> arguments)
{
    // ヘルプ表示
    if (arguments.Span.IncludeToken("--help"))
    {
        Console.WriteLine("user check <user> <subject>");
        Console.WriteLine("    user    : 対象ユーザ名");
        Console.WriteLine("    subject : 制限対象");
        return;
    }

    // パラメータ取得
    var user = arguments.TakeArgument(out arguments).ToString().ThrowIfWhite(() => new PavedMessageException($"user は必須です。"));
    var subject = arguments.TakeArgument(out arguments).ToString().ThrowIfWhite(() => new PavedMessageException($"subject は必須です。"));

    // 情報取得・表示
    using var userClient = context.Client.Sudo(user);
    var quotaState = await userClient.User.CheckQuotaOverAsync(subject, context.Breaker);
    var overState = quotaState ? "OK" : "Over";
    Console.WriteLine($"State: {overState}");
}

/// <summary>user packages コマンド</summary>
async ValueTask cmdUserPackagesAsync(ManageContext context, ReadOnlyMemory<char> arguments)
{
    // ヘルプ表示
    if (arguments.Span.IncludeToken("--help"))
    {
        Console.WriteLine("user packages <user>");
        Console.WriteLine("    user : 対象ユーザ名");
        return;
    }

    // パラメータ取得
    var user = arguments.TakeArgument(out arguments).ToString().ThrowIfWhite(() => new PavedMessageException($"user は必須です。"));

    // 情報取得・表示
    using var userClient = context.Client.Sudo(user);
    var packages = await userClient.User.ListQuotaPackagesAsync(cancelToken: context.Breaker);
    Console.WriteLine($"Packages:");
    foreach (var pkg in packages)
    {
        Console.WriteLine($"  [{pkg.type}] {pkg.name}({pkg.version}) {pkg.size?.ToHumanize()}");
    }
    if (packages.Length <= 0) Console.WriteLine("  Nothing");
}

/// <summary>user attachments コマンド</summary>
async ValueTask cmdUserAttachmentsAsync(ManageContext context, ReadOnlyMemory<char> arguments)
{
    // ヘルプ表示
    if (arguments.Span.IncludeToken("--help"))
    {
        Console.WriteLine("user attachments <user>");
        Console.WriteLine("    user : 対象ユーザ名");
        return;
    }

    // パラメータ取得
    var user = arguments.TakeArgument(out arguments).ToString().ThrowIfWhite(() => new PavedMessageException($"user は必須です。"));

    // 情報取得・表示
    using var userClient = context.Client.Sudo(user);
    var attachments = await userClient.User.ListQuotaAttachmentsAsync(cancelToken: context.Breaker);
    Console.WriteLine($"Attachments:");
    foreach (var attach in attachments)
    {
        Console.WriteLine($"  {attach.name} {attach.size?.ToHumanize()}");
    }
    if (attachments.Length <= 0) Console.WriteLine("  Nothing");
}

/// <summary>user artifacts コマンド</summary>
async ValueTask cmdUserArtifactsAsync(ManageContext context, ReadOnlyMemory<char> arguments)
{
    // ヘルプ表示
    if (arguments.Span.IncludeToken("--help"))
    {
        Console.WriteLine("user artifacts <user>");
        Console.WriteLine("    user : 対象ユーザ名");
        return;
    }

    // パラメータ取得
    var user = arguments.TakeArgument(out arguments).ToString().ThrowIfWhite(() => new PavedMessageException($"user は必須です。"));

    // 情報取得・表示
    using var userClient = context.Client.Sudo(user);
    var artifacts = await userClient.User.ListQuotaArtifactsAsync(cancelToken: context.Breaker);
    Console.WriteLine($"Artifacts:");
    foreach (var artifact in artifacts)
    {
        Console.WriteLine($"  {artifact.name} {artifact.size?.ToHumanize()}");
    }
    if (artifacts.Length <= 0) Console.WriteLine("  Nothing");
}

/// <summary>org info コマンド</summary>
async ValueTask cmdOrgInfoAsync(ManageContext context, ReadOnlyMemory<char> arguments)
{
    // ヘルプ表示
    if (arguments.Span.IncludeToken("--help"))
    {
        Console.WriteLine("org info <org>");
        Console.WriteLine("    org : 対象組織名");
        return;
    }

    // パラメータ取得
    var org = arguments.TakeArgument(out arguments).ToString().ThrowIfWhite(() => new Exception($"org は必須です。"));

    // 情報取得・表示
    var info = await context.Client.Organization.GetQuotaAsync(org, context.Breaker);
    Console.WriteLine($"Used:");
    if (info.used?.size is var used && used != null)
    {
        if (used.assets != null)
        {
            Console.WriteLine($"  Assets:");
            Console.WriteLine($"    Artifacts = {used.assets.artifacts?.ToHumanize()}");
            Console.WriteLine($"    Attachments:");
            if (used.assets.attachments != null)
            {
                Console.WriteLine($"      Issues   = {used.assets.attachments.issues?.ToHumanize()}");
                Console.WriteLine($"      Releases = {used.assets.attachments.releases?.ToHumanize()}");
            }
            Console.WriteLine($"    Packages:");
            if (used.assets.packages != null)
            {
                Console.WriteLine($"      All = {used.assets.packages.all?.ToHumanize()}");
            }
        }
        if (used.git != null)
        {
            Console.WriteLine($"  Git:");
            Console.WriteLine($"    LFS = {used.git.LFS?.ToHumanize()}");
        }
        if (used.repos != null)
        {
            Console.WriteLine($"  Repos:");
            Console.WriteLine($"    Public  = {used.repos.@public?.ToHumanize()}");
            Console.WriteLine($"    Private = {used.repos.@private?.ToHumanize()}");
        }
    }
    if (0 < info.groups?.Count)
    {
        foreach (var group in info.groups)
        {
            Console.WriteLine($"Group: Name={group.name}");
            foreach (var rule in group.rules ?? [])
            {
                Console.WriteLine($" - Rule: Name={rule.name}, Limit={rule.limit?.ToHumanize()}");
            }
        }
    }
}

/// <summary>org check コマンド</summary>
async ValueTask cmdOrgCheckAsync(ManageContext context, ReadOnlyMemory<char> arguments)
{
    // ヘルプ表示
    if (arguments.Span.IncludeToken("--help"))
    {
        Console.WriteLine("org check <org> <subject>");
        Console.WriteLine("    org     : 対象組織名");
        Console.WriteLine("    subject : 制限対象");
        return;
    }

    // パラメータ取得
    var org = arguments.TakeArgument(out arguments).ToString().ThrowIfWhite(() => new PavedMessageException($"org は必須です。"));
    var subject = arguments.TakeArgument(out arguments).ToString().ThrowIfWhite(() => new PavedMessageException($"subject は必須です。"));

    // 情報取得・表示
    var quotaState = await context.Client.Organization.CheckQuotaOverAsync(org, subject, context.Breaker);
    var overState = quotaState ? "OK" : "Over";
    Console.WriteLine($"State: {overState}");
}

/// <summary>org packages コマンド</summary>
async ValueTask cmdOrgPackagesAsync(ManageContext context, ReadOnlyMemory<char> arguments)
{
    // ヘルプ表示
    if (arguments.Span.IncludeToken("--help"))
    {
        Console.WriteLine("org packages <org>");
        Console.WriteLine("    org : 対象組織名");
        return;
    }

    // パラメータ取得
    var org = arguments.TakeArgument(out arguments).ToString().ThrowIfWhite(() => new PavedMessageException($"org は必須です。"));

    // 情報取得・表示
    var packages = await context.Client.Organization.ListQuotaPackagesAsync(org, cancelToken: context.Breaker);
    Console.WriteLine($"Packages:");
    foreach (var pkg in packages)
    {
        Console.WriteLine($"  [{pkg.type}] {pkg.name}({pkg.version}) {pkg.size?.ToHumanize()}");
    }
    if (packages.Length <= 0) Console.WriteLine("  Nothing");
}

/// <summary>org attachments コマンド</summary>
async ValueTask cmdOrgAttachmentsAsync(ManageContext context, ReadOnlyMemory<char> arguments)
{
    // ヘルプ表示
    if (arguments.Span.IncludeToken("--help"))
    {
        Console.WriteLine("org attachments <org>");
        Console.WriteLine("    org : 対象組織名");
        return;
    }

    // パラメータ取得
    var org = arguments.TakeArgument(out arguments).ToString().ThrowIfWhite(() => new PavedMessageException($"org は必須です。"));

    // 情報取得・表示
    var attachments = await context.Client.Organization.ListQuotaAttachmentsAsync(org, cancelToken: context.Breaker);
    Console.WriteLine($"Attachments:");
    foreach (var attach in attachments)
    {
        Console.WriteLine($"  {attach.name} {attach.size?.ToHumanize()}");
    }
    if (attachments.Length <= 0) Console.WriteLine("  Nothing");
}

/// <summary>org artifacts コマンド</summary>
async ValueTask cmdOrgArtifactsAsync(ManageContext context, ReadOnlyMemory<char> arguments)
{
    // ヘルプ表示
    if (arguments.Span.IncludeToken("--help"))
    {
        Console.WriteLine("org artifacts <org>");
        Console.WriteLine("    org : 対象組織名");
        return;
    }

    // パラメータ取得
    var org = arguments.TakeArgument(out arguments).ToString().ThrowIfWhite(() => new PavedMessageException($"org は必須です。"));

    // 情報取得・表示
    var artifacts = await context.Client.Organization.ListQuotaArtifactsAsync(org, cancelToken: context.Breaker);
    Console.WriteLine($"Artifacts:");
    foreach (var artifact in artifacts)
    {
        Console.WriteLine($"  {artifact.name} {artifact.size?.ToHumanize()}");
    }
    if (artifacts.Length <= 0) Console.WriteLine("  Nothing");
}

/// <summary>実行コンテキスト情報</summary>
/// <param name="Client">APIクライアント</param>
/// <param name="Breaker">実行中断トークン</param>
public record ManageContext(ForgejoClient Client, CommandDefine Commands, CancellationToken Breaker);

/// <summary>コマンドハンドラデリゲート型</summary>
/// <param name="context">実行コンテキスト情報</param>
/// <param name="arguments">引数文字列</param>
public delegate ValueTask AsyncCommmandHandler(ManageContext context, ReadOnlyMemory<char> arguments);

/// <summary>コマンド定義</summary>
public class CommandDefine
{
    /// <summary>コマンド定義コンストラクタ</summary>
    /// <param name="Token">コマンド名</param>
    /// <param name="Description">コマンド概要</param>
    /// <param name="Subs">サブコマンド</param>
    /// <param name="Handler">コマンド処理ハンドラ</param>
    /// <param name="Aliases">コマンド名のエイリアス</param>
    public CommandDefine(string Token, string Description, CommandDefine[]? Subs = default, AsyncCommmandHandler? Handler = default, string[]? Aliases = default)
    {
        this.Token = Token;
        this.Description = Description;
        this.Subs = Subs;
        this.Handler = Handler;
        this.Aliases = Aliases;
        if (this.Subs != null)
        {
            foreach (var sub in this.Subs)
            {
                sub.Parent = this;
            }
        }
    }

    /// <summary>親コマンド</summary>
    public CommandDefine? Parent { get; private set; }
    /// <summary>コマンド名</summary>
    public string Token { get; }
    /// <summary>コマンド概要</summary>
    public string Description { get; }
    /// <summary>サブコマンド</summary>
    public CommandDefine[]? Subs { get; }
    /// <summary>コマンド処理ハンドラ</summary>
    public AsyncCommmandHandler? Handler { get; }
    /// <summary>コマンド名のエイリアス</summary>
    public string[]? Aliases { get; }

    /// <summary>コマンドパスを取得する</summary>
    /// <returns>コマンドパス</returns>
    public string MekeCommandPath()
    {
        static IEnumerable<string> walkAncestor(CommandDefine define)
        {
            if (define.Parent == null) yield break;
            yield return define.Token;
            if (define.Parent != null)
            {
                foreach (var ancestor in walkAncestor(define.Parent))
                {
                    yield return ancestor;
                }
            }
        }

        return walkAncestor(this).Reverse().JoinString(" ");
    }
}

/// <summary>コマンド関連の定数</summary>
public static class CommandConstants
{
    /// <summary>コマンドトークン区切り</summary>
    public static readonly char[] Separators = [' ', '\t'];
}

public static class Extensions
{
    /// <summary>コマンドラインから実行するコマンドを選択する</summary>
    /// <param name="root">入力コマンドライン</param>
    /// <param name="input">入力コマンドライン</param>
    /// <param name="args">コマンドラインの引数部分</param>
    /// <returns>実行するコマンド定義</returns>
    public static CommandDefine? SelectCommand(this CommandDefine root, ReadOnlyMemory<char> input, out ReadOnlyMemory<char> args)
    {
        // コマンド定義のサブコマンドから一致する物を選択する
        static CommandDefine? matchSubCommand(CommandDefine site, ReadOnlySpan<char> token)
        {
            // サブコマンドを持たない場合は一致無し
            if (site.Subs == null) return null;

            // サブコマンドの検索
            foreach (var sub in site.Subs)
            {
                // サブコマンド一致判定
                if (token.Equals(sub.Token, StringComparison.OrdinalIgnoreCase)) return sub;
                // エイリアスがある場合はそれに一致する物を検索
                if (sub.Aliases == null) continue;
                foreach (var alias in sub.Aliases)
                {
                    if (token.Equals(alias, StringComparison.OrdinalIgnoreCase)) return sub;
                }
            }
            return null;
        }

        // 最も深く一致するコマンド定義を検索
        var stage = root;
        var scan = input.Span;
        while (true)
        {
            // コマンドラインの最初のトークンに一致する定義の取得を試みる
            var token = scan.TakeSkipTokenAny(out var next, CommandConstants.Separators);
            var match = matchSubCommand(stage, token);
            if (match == null) break;

            // 一致したら次へ
            stage = match;
            scan = next.TrimStart();
        }

        // コマンドラインの残りをコマンド引数として返す
        args = input[^scan.Length..];

        return stage;
    }

    /// <summary>文字列から最初のトークンを取得する</summary>
    /// <param name="self">文字列</param>
    /// <param name="target">判定するトークン</param>
    /// <returns>トークン</returns>
    public static ReadOnlySpan<char> TakeArgument(this ReadOnlyMemory<char> self, out ReadOnlyMemory<char> next)
          => self.TakeSkipTokenAny(out next, CommandConstants.Separators).Span;

    /// <summary>文字列からトークンリストを取得する</summary>
    /// <param name="self">文字列</param>
    /// <returns>トークンリスト</returns>
    public static List<string> TakeArgList(this ReadOnlyMemory<char> self)
    {
        var list = new List<string>();
        var scan = self.Span;
        while (!scan.IsEmpty)
        {
            var token = scan.TakeSkipTokenAny(out scan, CommandConstants.Separators);
            list.Add(token.ToString());
        }
        return list;
    }
}